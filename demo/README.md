# 示例DEMO —— 基于MySQL数据库的MyBatis实体和映射文件生成模板
Demo文件夹中的模板，是经过<b>精心打磨</b>的、可以直接拿来用于生产的模板，它支持以下特性：

1. 一键生成实体类、MyBatis Repository、MyBatis Mapper
2. 实体类、MyBatis Repository和MyBatis Mapper均利用继承策略，划分出XXXX和XXXXBase两个文件，其中XXXX如果文件存在则不覆盖，XXXXBase每次生成都会覆盖。
如果在生成后你需要做一些代码上的调整，请在XXXX文件中修改，而不要在XXXXBase中修改。这样做的好处是一旦我们的表结构发生变化需要重新生成时，不会覆盖您手动改过的代码。
3. 如果表存在is_deleted字段，生成的delete方法是逻辑删除而不是物理删除
4，如果表存在record_version字段，update语句带有乐观锁，即update .... set record_version=record_version + 1 where .... and record_version=#{record_version}
5. 如果表存在create_time，insert语句这一列的值是now()
6. 如果表存在update_time, insert和update语句这一列的值是now()

入口模板：tpl1.jm.vm

```
##tpl1.jm.vm

## model是Database对象
#set($cfg = {
    "basePkg" : "com.abc.demo",
    "tplPath" : "./tpl",
    "baseTargetPath" : "../src/main/java/com/abc/demo",
    "db":${model}
})

#set($cfg.package = "${cfg.basePkg}.entity")
#set($cfg.modelPkg = "${cfg.basePkg}.model")
#set($cfg.targetPath = "${cfg.baseTargetPath}/entity")
$processor.process("${cfg.tplPath}/Entity.tpl.vm", $cfg)

#set($cfg.entityPkg = "${cfg.basePkg}.entity")
#set($cfg.repoPkg = "${cfg.basePkg}.repository")
#set($cfg.targetPath = "${cfg.baseTargetPath}/repository")
$processor.process("${cfg.tplPath}/Repository.tpl.vm", $cfg)

#set($cfg.targetPath = "../src/main/resources/mapper")
$processor.process("${cfg.tplPath}/Mapper.tpl.vm", $cfg)
```

在tpl1.jm.vm模板里，调用$processor.process分别解析Entity、Repository和Mapper，并向引擎传递了新的model

```
## Entity.tpl.vm

## 此时，model是tpl1.jm.vm中传入的cfg

#foreach($table in $model.db.tables)

    #set($entityModel = {"table" : $table, "package":$model.package, "modelPkg":$model.modelPkg})
    #set($entityModel.className = ${table.className})

    ##生成xxxxBase.java，如果目标文件存在，替换
    $processor.generate("${model.tplPath}/EntityBase.vm", "${model.targetPath}/${table.className}Base.java", true, $entityModel)
    
    ##生成xxxx.java，如果目标文件存在，忽略，不替换
    $processor.generate("${model.tplPath}/Entity.vm", "${model.targetPath}/${table.className}.java", false, 
)
#end
```
在Entity.tpl.vm里，调用$processor.generate生成EntityBase和Entity，并像引擎传递新的model
对于EntityBase，每次生成都会替换目标文件；对于Entity，如果目标文件已经存在了，就会忽略这个文件的生成。

下面再看看EntityBase.vm的定义片段
```
## 此时，model是Entity.tpl.vm中传入的entityModel
package $model.package;

/**
* ${model.table.remarks}
* <p>
* ${model.className}Base.
* </p>
* <p>
* auto generated by jasmine, please do not modify it!
* </p>
*/
public class ${model.className}Base {

## ~~ begin column to field
#foreach($column in $model.table.columns)
    /**
    * ${column.remarks}
    * type ${column.type}
    */
    private $column.javaType $column.fieldName;
#end  ## ~~ end column to field
...
```